"""build_exe.py

Bygger en *onefile* Windows .exe for Utvalg ved hjelp av PyInstaller.

Målgruppen er kollegaer som skal kunne dobbeltklikke en enkelt fil (Utvalg.exe)
uten å installere Python.

Standard (GUI, ingen konsoll):
    python build_exe.py

Konsoll (for feilsøking):
    python build_exe.py --console

Forutsetninger:
    pip install pyinstaller

Output (default):
    dist_exe/Utvalg.exe

Hvorfor egen build-script?
    - Sikrer at vi alltid inkluderer `ui_main` (dynamisk import via app.py)
    - Setter arbeidsmappe til der .exe ligger (runtime hook), så lokale filer
      som .ml_map.json havner ved siden av exe (ikke i C:/Windows/System32).

NB:
    Dette scriptet kjører PyInstaller. Det er normalt at bygg tar litt tid,
    spesielt første gang (pandas/numpy er store pakker).
"""

from __future__ import annotations

import argparse
import importlib.util
import logging
import shutil
import subprocess
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional, Sequence

log = logging.getLogger(__name__)


@dataclass(frozen=True)
class BuildOptions:
    """Parametre for byggejobben."""

    name: str = "Utvalg"
    onefile: bool = True
    console: bool = False  # default: windowed (ingen konsoll) for Tkinter
    clean: bool = True

    # Output-foldere (relativt til prosjektrot)
    dist_dir: str = "dist_exe"
    work_dir: str = "build_exe"

    # Ekstra PyInstaller-flagg (avansert)
    extra_hidden_imports: List[str] = field(default_factory=list)
    extra_args: List[str] = field(default_factory=list)

    # Dry-run: bygg kommando, men ikke kjør PyInstaller
    dry_run: bool = False


def find_project_root(start: Optional[Path] = None) -> Path:
    """Finn mappen som inneholder app.py.

    Vi forventer at build_exe.py ligger i samme mappe som app.py.
    Men vi søker også oppover for robusthet.
    """
    here = (start or Path(__file__).resolve().parent).resolve()
    for p in [here, *here.parents]:
        if (p / "app.py").exists():
            return p
    return here


def is_pyinstaller_available() -> bool:
    """Returnerer True hvis PyInstaller er installert i gjeldende miljø."""
    return importlib.util.find_spec("PyInstaller") is not None


def ensure_pyinstaller_available() -> None:
    """Kaster RuntimeError med brukervennlig melding hvis PyInstaller mangler."""
    if is_pyinstaller_available():
        return
    raise RuntimeError(
        "PyInstaller er ikke installert i dette Python-miljøet.\n"
        "Installer med:  pip install pyinstaller\n"
        "Deretter:      python build_exe.py"
    )


def write_runtime_hook_set_cwd(target_dir: Path) -> Path:
    """Skriv en runtime-hook som setter CWD til mappen der .exe ligger.

    Dette er viktig i Windows når appen startes via snarvei/Start-meny.
    Mange deler av prosjektet leser/skriver lokale filer (f.eks. .ml_map.json).
    """
    target_dir.mkdir(parents=True, exist_ok=True)
    hook_path = target_dir / "runtime_hook_set_cwd.py"
    hook_path.write_text(
        """# Auto-generated by build_exe.py
import os
import sys

try:
    if getattr(sys, 'frozen', False) and hasattr(sys, 'executable'):
        exe_dir = os.path.dirname(sys.executable)
        if exe_dir and os.path.isdir(exe_dir):
            os.chdir(exe_dir)
except Exception:
    # Best effort: ikke stopp appen om noe feiler her
    pass
""",
        encoding="utf-8",
    )
    return hook_path


def _iter_hidden_imports(opts: BuildOptions) -> List[str]:
    # app.py importerer ui_main via importlib, så den må eksplisitt inkluderes
    base = ["ui_main"]
    extra = [s.strip() for s in (opts.extra_hidden_imports or []) if str(s).strip()]
    out: List[str] = []
    for item in [*base, *extra]:
        if item not in out:
            out.append(item)
    return out


def build_pyinstaller_args(project_root: Path, opts: BuildOptions, runtime_hook: Path) -> List[str]:
    """Bygg argumentlisten til PyInstaller."""
    entry_script = project_root / "app.py"
    if not entry_script.exists():
        raise FileNotFoundError(f"Fant ikke app.py i {project_root}")

    dist_dir = project_root / opts.dist_dir
    work_dir = project_root / opts.work_dir

    args: List[str] = [
        "--noconfirm",
        f"--name={opts.name}",
        f"--distpath={dist_dir}",
        f"--workpath={work_dir}",
        f"--specpath={work_dir}",
        "--clean" if opts.clean else "",
        "--onefile" if opts.onefile else "",
        "--console" if opts.console else "--noconsole",
        "--runtime-hook",
        str(runtime_hook),
    ]

    # Fjern tomme strenger
    args = [a for a in args if a]

    # Hidden imports
    for mod in _iter_hidden_imports(opts):
        args.extend(["--hidden-import", mod])

    # Ekstra argumenter
    for a in (opts.extra_args or []):
        if a and str(a).strip():
            args.append(str(a).strip())

    # Entry
    args.append(str(entry_script))
    return args


def build_command(pyinstaller_args: Sequence[str]) -> List[str]:
    """Lag full kommando som kjøres."""
    return [sys.executable, "-m", "PyInstaller", *list(pyinstaller_args)]


def clean_build_dirs(project_root: Path, opts: BuildOptions) -> None:
    """Fjern dist/work-mapper hvis de finnes."""
    for rel in (opts.dist_dir, opts.work_dir):
        p = (project_root / rel).resolve()
        if p.exists() and p.is_dir():
            log.info("Fjerner %s", p)
            shutil.rmtree(p, ignore_errors=True)


def run_build(opts: BuildOptions) -> Path:
    """Kjør bygg og returner forventet exe-path."""
    project_root = find_project_root()
    ensure_pyinstaller_available()

    if opts.clean:
        clean_build_dirs(project_root, opts)

    work_dir = project_root / opts.work_dir
    runtime_hook = write_runtime_hook_set_cwd(work_dir)

    pyinstaller_args = build_pyinstaller_args(project_root, opts, runtime_hook)
    cmd = build_command(pyinstaller_args)

    log.info("Kjører: %s", " ".join(cmd))
    if opts.dry_run:
        log.info("Dry-run: PyInstaller kjøres ikke.")
    else:
        subprocess.run(cmd, cwd=str(project_root), check=True)

    exe_path = (project_root / opts.dist_dir / f"{opts.name}.exe").resolve()
    return exe_path


def _parse_args(argv: Optional[Sequence[str]] = None) -> BuildOptions:
    p = argparse.ArgumentParser(description="Bygg onefile .exe med PyInstaller")
    p.add_argument("--name", default="Utvalg", help="Navn på exe (uten .exe)")
    p.add_argument("--onedir", action="store_true", help="Bygg onedir i stedet for onefile")
    p.add_argument("--console", action="store_true", help="Vis konsollvindu (for feilsøking)")
    p.add_argument("--no-clean", action="store_true", help="Ikke slett tidligere build/dist")
    p.add_argument("--dry-run", action="store_true", help="Print kommando, men ikke kjør")
    p.add_argument(
        "--dist-dir",
        default="dist_exe",
        help="Output-mappe for .exe (relativ til prosjektrot)",
    )
    p.add_argument(
        "--work-dir",
        default="build_exe",
        help="Arbeidsmappe for PyInstaller (relativ til prosjektrot)",
    )
    p.add_argument(
        "--hidden-import",
        action="append",
        default=[],
        help="Legg til ekstra hidden import (kan brukes flere ganger)",
    )
    p.add_argument(
        "--pyi-arg",
        action="append",
        default=[],
        help="Send et ekstra rå-argument til PyInstaller (kan brukes flere ganger)",
    )

    ns = p.parse_args(argv)

    return BuildOptions(
        name=str(ns.name).strip() or "Utvalg",
        onefile=not bool(ns.onedir),
        console=bool(ns.console),
        clean=not bool(ns.no_clean),
        dist_dir=str(ns.dist_dir).strip() or "dist_exe",
        work_dir=str(ns.work_dir).strip() or "build_exe",
        extra_hidden_imports=list(ns.hidden_import),
        extra_args=list(ns.pyi_arg),
        dry_run=bool(ns.dry_run),
    )


def main(argv: Optional[Sequence[str]] = None) -> int:
    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
    try:
        opts = _parse_args(argv)
        exe_path = run_build(opts)
        if opts.dry_run:
            log.info("(dry-run) Forventet output: %s", exe_path)
        else:
            log.info("Ferdig! Output: %s", exe_path)
        return 0
    except subprocess.CalledProcessError as e:
        log.error("Bygg feilet (PyInstaller returnerte %s).", e.returncode)
        return int(e.returncode or 1)
    except Exception as e:
        log.error(str(e))
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
